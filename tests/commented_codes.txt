





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //this is for more precise collision to check if the object is at the roof or not
    //float tempObjectMaxX = 0.5f;
    //float tempObjectMinX = -0.5f;
    //float tempObjectMaxZ = 0.5f;
    //float tempObjectMinZ = -0.5f;


    //    if(m_cameraPos.x <= tempObjectMaxX &&
    //       m_cameraPos.x >= tempObjectMinX &&
    //       m_cameraPos.z <= tempObjectMaxZ &&
    //       m_cameraPos.z >= tempObjectMinZ)
    //


    //store all the unique verticies
    // GLfloat verticies[] = {

    //     //positions             //colors
    //     0.5f,  0.5f, 0.0f,      1.0f, 0.5f, 0.0f,
    //     0.5f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f,
    //    -0.5f,  0.5,  0.0f,      0.0f, 0.0f, 1.0f,
    //    -0.5f, -0.5f, 0.0f,      1.0f, 0.0f, 0.0f,
    //    -1.0f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f

    // };





    // GLfloat verticies[] = {

    //     // first triangle
    //     0.5f,  0.5f, 0.0f, 
    //     0.5f, -0.5f, 0.0f, 
    //     -0.5f, 0.5,  0.0f, 

    //     // second triangle
    //     0.5f, -0.5f, 0.0f,  
    //     -0.5f, -0.5f, 0.0f, 
    //     -0.5f,  0.5f, 0.0f,  

    //     // third triangle
    //     -0.5f, 0.5f,  0.0f,
    //     -0.5f, -0.5f, 0.0f,
    //     -1.0f, -0.5f, 0.0f

    // };




    //create vertex shader object and compile the vertex shader source code
    // GLuint vertexShader;
    // vertexShader = glCreateShader(GL_VERTEX_SHADER);

    // glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    // glCompileShader(vertexShader);
 

    // //create fragment shader object and compile the fragment shader source code
    // GLuint fragmentShader;
    // fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

    // glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    // glCompileShader(fragmentShader);
 

    // //link both the shadres here
    // GLuint shaderProgram;
    // shaderProgram = glCreateProgram();

    // glAttachShader(shaderProgram, vertexShader);
    // glAttachShader(shaderProgram, fragmentShader);
    // glLinkProgram(shaderProgram);


    // //delete the shaders
    // glDeleteShader(vertexShader);
    // glDeleteShader(fragmentShader);




    // //generate the vertex array and vertex buffer objects(the order matters)
    // GLuint VAO, VBO;

    // //glGenVertexArrays(1, &VAO);
    // glGenBuffers(1, &VBO);
    // glGenVertexArrays(1, &VAO);    

    // //bind the vertex array and vertex buffer objects(the order matters)
    // glBindVertexArray(VAO);

    // glBindBuffer(GL_ARRAY_BUFFER, VBO);
    // glBufferData(GL_ARRAY_BUFFER, Entity::uniqueVerticies * sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, 5*3*sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, verticiesNumber*triangleNumber*sizeof(verticies), verticies, GL_STATIC_DRAW);

    
    // GLuint EBO;
    // glGenBuffers(1, &EBO);
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    // glBufferData(GL_ELEMENT_ARRAY_BUFFER, Entity::triangleNumber * sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);
    // //glBufferData(GL_ELEMENT_ARRAY_BUFFER, 9*sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);


    // //create vertex attribute pointer and enable vertex attribute array
    // glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(GLfloat), (void*)0);
    // glEnableVertexAttribArray(0);








    // while (!glfwWindowShouldClose(window))
    // {
    //     getKeyboardInput(window);

    //     glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    //     glClear(GL_COLOR_BUFFER_BIT);

    //     shader.useProgram();
    //     glBindVertexArray(VAO);
    //     glDrawElements(GL_TRIANGLES, 9, GL_UNSIGNED_INT, 0);
    //     //glDrawArrays(GL_TRIANGLES, 0, verticiesNumber);

    //     glfwSwapBuffers(window);
    //     glfwPollEvents();    
    // }




















    
    // if(glfwGetKey(m_window, GLFW_KEY_UP) == GLFW_PRESS)
    // {                                    
    //     transformation.translate.x = 1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(100.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }        
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, 0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_DOWN) == GLFW_PRESS)
    // {    
    //     transformation.translate.x = -1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }    
    //     else
    //     { 
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, -0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.05f, 0.0f, 0.0f));
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_LEFT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else 
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(-0.05f, 0.0f, 0.0f));
    //     }
    // }















/*

        //cameraPos = cameraPos + cameraSpeed * directionVector;
        // if(glfwGetKey(m_window, GLFW_KEY_SPACE) == GLFW_PRESS)
        // {
        //     m_cameraPos = m_cameraPos + m_cameraSpeed * Calculate::m_directionVector;
        // }
        // else
        //{
            //cameraPos = cameraPos + cameraSpeed * directionVector;
            if(!collided)
            {
                m_cameraPos.x = m_cameraPos.x + m_cameraSpeed * Calculate::m_directionVector.x;
                m_cameraPos.z = m_cameraPos.z + m_cameraSpeed * Calculate::m_directionVector.z;
            }
            //cameraPos.y = lastCameraYpos;
        //}       
        
*/




//store all the unique vertex attributes
// Vertex verticies[] = {

//     {{0.5f,   0.5f, 0.5f}, {1.0f, 0.5f, 0.0f}},
//     {{0.5f,  -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f,}},
//     {{-0.5f,  0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}},
//     {{-0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}}
//     //{{-1.0f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}}

// };


// //store the triangles verticies in order to render it more efficiently
// GLuint indicies[] = {

//     0, 1, 2,       //first triangle
//     1, 3, 2       //seconds triangle
//     //2, 3, 4        //third triangle

// };







//this algorithm is still legendary. I know the pain of creating this from scratch

    // //beta = beta + 0.01f;
    // m_timeElapsed = m_timeElapsed + 0.01f;

    // float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
    // float jumpSpeed = 6.0f;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);   //here was beta

    // ////here was beta
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     m_keepRunning = false;
    //     //alpha = 0.0f;
    //     //beta = 0.455f;
    //     m_timeElapsed = 0.0f;
    //     m_cameraPos.y = 0.0f;
    // }

// also this which is more legendary cause it was the first one

    // alpha = alpha + 0.01f;
    // float objectHeight;
    // float cameraHeight = m_cameraPos.y;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);  //here was alpha

    // //float height = distanceFromGround - 43.0f * (alpha - 0.262f) * (alpha - 0.262f) + jumpMaxHeight;

    // //here was alpha
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     //alpha = 0.0f;
    //     m_timeElapsed = 0.0f;
    //     m_jumped = false;
    //     m_cameraPos.y = 0.0f;
    // }



//the mathematical function for the jumping algorithm that i used before implementing Pure Physics
//float value = A * glm::sin(k * (theta - leftRightShift)) + upDownShift


//it is also an good one but not as good as the previous one
//here it uses parabola instead of the sine function for some optimization(I don't know if that is actually optimized)

    // float jumpSpeed = 6.0f;
    // float jumpMaxHeight = 3.0f;
    // float shift = std::sqrt(jumpMaxHeight);

    // m_cameraPos.y = jumpMaxHeight - (jumpSpeed * m_timeElapsed - shift) * (jumpSpeed * m_timeElapsed - shift);







//this is the basic shader implementation which is basically messed up

//    Shader vertexShader(GL_VERTEX_SHADER, "../GLSL/vertexShaderSource.glslv");
//    Shader fragmentShader(GL_FRAGMENT_SHADER, "../GLSL/fragmentShaderSource.glslf");
//    vertexShader.setup();
//    fragmentShader.setup();
//
//    GLuint shaderProgramID = Shader::attachAndLink(vertexShader.ID(), fragmentShader.ID());
//
//    vertexShader.remove();
//    fragmentShader.remove();




//class Shader
//{
//public:
//    typedef struct ShaderFile
//    {
//        std::string source;
//        std::string path;
//    }ShaderFile;
//
//    Shader(const GLenum shaderName, const std::string &&shaderFilePath)
//    {
//        m_shaderID = glCreateShader(shaderName);
//        m_shaderFile.path = std::move(shaderFilePath);
//    }
//
//    [[nodiscard]] auto ID()->GLuint{return m_shaderID;}
//
//    void readSource();
//    void setupSuccessLog();
//    void setup();
//    void remove(){glDeleteShader(m_shaderID);}
//
//
//    [[nodiscard]] static auto attachAndLink(GLuint vertexShaderID, GLuint fragmentShaderID)->GLuint;
//    static void compilationSuccessLog(GLuint shaderProgramID);
//    inline static void useProgram(GLuint shaderProgramID){glUseProgram(shaderProgramID);}
//    inline static void removeProgram(GLuint shaderProgramID){glDeleteProgram(shaderProgramID);}
//
//private:
//
//    GLuint     m_shaderID;
//    ShaderFile m_shaderFile;
//};



//m_timeElapsed = m_timeElapsed + 0.01f;
//float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
//float jumpSpeed = 6.0f;







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

The main Engine loop:


    while(window.running())
    {        
        //Transform transform;
        window.getKeyboardInput();
        camera.getKeyboardInput(window.windowAddress());                


        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glEnable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        


        //shaders.useProgram();
        Shader::useProgram(shaderProgramID);


        //view = glm::lookAt(cameraPos, targetPos, upVecPos);
        //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
        camera.lookAtTarget();


        //CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        

        CoordinateTransformation::perspective = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);


        //transform from coordinate to coordinate

        CoordinateTransformation::modelLocation(shaderProgramID);
        camera.viewLocation(shaderProgramID); //CoordinateTransformation::viewLocation(shaderProgramID);        
        CoordinateTransformation::perspectiveLocation(shaderProgramID);

        // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
        // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));  
    

        //bind the vertex attribute array and draw the premitive
        glBindVertexArray(VAO);
        //glDrawArrays(GL_TRIANGLES, 0, 36);
        glDrawElements(GL_TRIANGLES, Entity::totalIndicies, GL_UNSIGNED_INT, 0);

        window.swapBuffers();
        window.pollEvents();
    }

#endif




// git config --global user.name "Anfal Abon"
// git config --global user.email "codinghub447@gmail.com"
// git config --global user.email codinghub447@gmail.com
// git config --global code.editor vscode

/////////////////////////////////////////necesseary headers/////////////////////////////////////////////////////////////


// #include "Shader.hpp"
// #include "Window.h"
// #include "Camera.hpp"
// #include "Entities.hpp"
// #include "CoordinateTransformation.hpp"
// #include "InitializeEngine.hpp"

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>
// #include <glm/gtc/type_ptr.hpp>
// #include <glm/ext.hpp>
// #include <glm/gtx/string_cast.hpp>
// #include <SFML/Audio.hpp>

// #include <iostream>
// #include <thread>












///////////////////////////////////////////////////////////////////////////////



//    entityTransform.transform();
//    camera->setPerspective();
//
//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    camera->perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

//    entityTransform.m_model = glm::rotate(entityTransform.m_model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    entityTransform.m_model = glm::translate(entityTransform.m_model, glm::vec3(0.0f, 0.0f, 0.0f));
//    entityTransform.m_perspective = glm::perspective(glm::radians(camera->zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    entityTransform.perspectiveLocation(entityShaders.ProgramID());
//

///////////////////////////////////////////////////////////////////////////////

//    CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    CoordinateTransformation::perspective = glm::perspective(glm::radians(camera.zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

    //transform coordinate to coordinate
//    CoordinateTransformation::modelLocation(entityShaders.ProgramID());
//    camera.viewLocation(entityShaders.ProgramID());
//    CoordinateTransformation::perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 GLuint entityTotalIndicies,
                 Shader &entityShaders,
                 struct CoordinateTransformation &entityTransform,
                 Entity &entity)

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 Entity *entity)
{

    //will add camera.update(), entity.update(), scene.update(), scene.render(), entity.render()
    //but for now entity and scene is same.
    //So it will be camera.update(), entity.update(), entity.render()
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


    //    GLuint objectLocation = glGetUniformLocation(shaderProgramID, "objectColor");
    //    glUniform3f(objectLocation, 1.0f, 0.5f, 0.31f);

    //    GLuint lightLocation = glGetUniformLocation(shaderProgramID, "lightColor");
    //    glUniform3f(lightLocation, 1.0f, 1.0f, 1.0f);

    // float timeSinceInit = glfwGetTime();
    // float changingColor = 0.5f * (glm::sin(timeSinceInit) + 1.0f);
    // GLuint vertexColorLocation = glGetUniformLocation(entityShaders.ProgramID(), "vertexColor");
    // glUniform3f(vertexColorLocation, changingColor, changingColor - 0.5, changingColor + 0.5);


    //view = glm::lookAt(cameraPos, targetPos, upVecPos);
    //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));


    //we have to maintain the execution sequence of functions
    //will use update() funtion to update the Engines frames(for now the update objects are entity and camera)


#define UPDATE_FUNCTIONS
#ifdef NOT_UPDATE_FUNCTIONS
    entity.getShader().useProgram();

    entity.getTransformation().transform();
    camera->setPerspective();
    entity.getTransformation().modelLocation(entity.getShader().ProgramID());
    camera->viewLocation(entity.getShader().ProgramID());
    camera->perspectiveLocation(entity.getShader().ProgramID());

    camera->lookAtTarget();

    glBindVertexArray(VAO);

    entity.render();
#else

    //binding vertex array object before entity.render() is better
    glBindVertexArray(VAO);

//    camera->setShaderProgramID(entity->getShader().ProgramID());
    camera->update();

    entity->update();
//    camera->update();
    entity->render();

#endif


    // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
    // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));

    //bind the vertex attribute array and draw the premitive
    //glBindVertexArray(VAO);
    ////glDrawArrays(GL_TRIANGLES, 0, 36);
    //glDrawElements(GL_TRIANGLES, entityTotalIndicies, GL_UNSIGNED_INT, 0);

}

///////////////////////////////////////////////////////////////////////////////


//    if(m_addedNewEntityShader)
//    {
//        this->viewLocation();
//        this->perspectiveLocation();
//        m_addedNewEntityShader = false;
//    }

///////////////////////////////////////////////////////////////////////////////






















